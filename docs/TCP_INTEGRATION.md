# TCP Integration Reference

Complete reference for the RailwayStudio TCP protocol.

> **Quick Start?** See [TCP_QUICKSTART.md](TCP_QUICKSTART.md) for a 5-minute setup guide.

## Protocol Overview

- **Protocol**: TCP
- **Default Port**: 5555 (configurable)
- **Format**: Newline-delimited JSON (`\n` terminated)
- **Encoding**: UTF-8
- **Connection**: Persistent (keep-alive recommended)

## Message Types

### 1. Status Update

Update a single block's status.

**Request:**
```json
{
  "type": "status_update",
  "block_id": "BL001001",
  "status": "blocked"
}
```

**Fields:**
- `type`: `"status_update"` (optional, default)
- `block_id`: External Block ID (e.g., `BL001001`)
- `status`: `"free"`, `"reserved"`, `"blocked"`, or `"unknown"`

**Response:**
```json
{
  "type": "ack",
  "block_id": "BL001001",
  "status": "received"
}
```

### 2. Batch Update

Update multiple blocks in one message.

**Request:**
```json
{
  "type": "batch_update",
  "updates": [
    {"block_id": "BL001001", "status": "blocked"},
    {"block_id": "BL001002", "status": "reserved"},
    {"block_id": "BL001003", "status": "free"}
  ]
}
```

**Response:**
```json
{
  "type": "ack",
  "updates_received": 3,
  "status": "received"
}
```

### 3. Ping/Pong

Test connection health.

**Request:**
```json
{
  "type": "ping",
  "timestamp": 1234567890
}
```

**Response:**
```json
{
  "type": "pong",
  "timestamp": 1234567890
}
```

## Status Types & Colors

| Status     | Description          | Color  | Hex     |
|------------|---------------------|--------|---------|
| `free`     | Block available     | Green  | #48BB78 |
| `reserved` | Reserved for train  | Orange | #FFA500 |
| `blocked`  | Occupied            | Red    | #E53E3E |
| `unknown`  | Unknown/error state | Gray   | #888888 |

## Connection Flow

1. **Client connects** to server (e.g., `192.168.1.100:5555`)
2. **Server sends welcome:**
   ```json
   {
     "type": "welcome",
     "message": "Connected to RailwayStudio TCP Server",
     "client_id": "client_1",
     "protocol_version": "1.0"
   }
   ```
3. **Client sends updates** (status_update or batch_update)
4. **Server acknowledges** each message
5. **Client disconnects** when done (or keeps connection alive)

## Block ID Requirements

**Use External Block IDs:**
- Format: `BL001001`, `BL002001`, etc.
- Found in your JSON layout under `blockGroups[].blocks[].blockId`
- Displayed above rails in Editor/Monitor views
- Generated by "Auto-Create Groups" in Editor

**Don't use Internal Rail IDs:**
- Format: `rail_0001`, `rail_0002`
- Internal implementation details
- Not exported to JSON
- May change between sessions

## Message Format Rules

1. **One message per line** - terminated with `\n`
2. **Valid JSON** - use `json.dumps()` or equivalent
3. **UTF-8 encoding**
4. **No empty messages**

**Correct:**
```python
message = json.dumps(update) + '\n'
sock.send(message.encode('utf-8'))
```

**Incorrect:**
```python
# Missing newline
sock.send(json.dumps(update).encode('utf-8'))  # ❌

# Multiple messages without delimiters
sock.send(json.dumps(msg1) + json.dumps(msg2))  # ❌
```

## Error Handling

The server handles errors gracefully:
- Invalid JSON → Logs error, keeps connection open
- Unknown block ID → Logs warning, sends ACK
- Missing fields → Logs error, keeps connection open
- Invalid status → Logs error, keeps connection open

**The connection is never closed due to malformed messages.**

Check the Network Log in Monitor view for detailed error messages.

## Performance Tips

1. **Use batch updates** for multiple blocks (more efficient)
2. **Keep connection alive** (don't reconnect for each update)
3. **Server handles 100+ updates/second** easily
4. **No rate limiting** currently implemented

## Python Example

```python
import socket
import json
import time

class RailwayClient:
    def __init__(self, host, port):
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.connect((host, port))
        # Read welcome
        welcome = self.sock.recv(1024).decode('utf-8')
        print(welcome)
    
    def update_block(self, block_id, status):
        msg = {
            "type": "status_update",
            "block_id": block_id,
            "status": status
        }
        self.sock.send((json.dumps(msg) + '\n').encode('utf-8'))
        response = self.sock.recv(1024).decode('utf-8')
        return json.loads(response)
    
    def update_batch(self, updates):
        msg = {
            "type": "batch_update",
            "updates": updates
        }
        self.sock.send((json.dumps(msg) + '\n').encode('utf-8'))
        response = self.sock.recv(1024).decode('utf-8')
        return json.loads(response)
    
    def close(self):
        self.sock.close()

# Usage
client = RailwayClient('192.168.1.100', 5555)
client.update_block('BL001001', 'blocked')
client.update_batch([
    {"block_id": "BL001002", "status": "reserved"},
    {"block_id": "BL001003", "status": "free"}
])
client.close()
```

## Network Configuration

The server binds to the address configured in Settings (default: `0.0.0.0` = all interfaces).

**In Settings:**
- TCP Port: Default 5555
- TCP Bind Address: 
  - `0.0.0.0` = Accept from any IP (recommended for Docker)
  - Specific IP = Only accept on that interface

**In Monitor:**
- Temporarily override bind address for testing
- Auto-detects and displays your host IPs

## Security Considerations

- **No authentication** currently implemented
- **No encryption** (plain TCP)
- Server binds to all interfaces by default
- Use firewall rules to restrict access if needed
- Consider running on isolated network for production

## See Also

- [TCP_QUICKSTART.md](TCP_QUICKSTART.md) - 5-minute setup guide
- [MVC_ARCHITECTURE.md](MVC_ARCHITECTURE.md) - Codebase architecture
- `examples/docker_tcp_client.py` - Complete working example
- `examples/extract_block_ids.py` - Extract Block IDs from layouts
